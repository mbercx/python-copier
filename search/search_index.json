{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>A <code>copier</code>-based template for Python packages.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udce6 Package management:<ul> <li>Develop with your preferred tools (extras, <code>uv</code> or Hatch).</li> <li>Build your package with Hatch. </li> </ul> </li> <li>\ud83e\uddf9 Pre-commit: Format and lint your code with Ruff.</li> <li>\ud83e\uddea Tests: Write tests with <code>pytest</code>.</li> <li>\ud83d\udcda Documentation: Write docs in MyST or MkDocs.</li> <li>\u2699\ufe0f GitHub Actions:<ul> <li>Deploy documentation to GitHub Pages or Read the Docs.</li> <li>Run pre-commit checks and tests on every pull request.</li> </ul> </li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>Follow the <code>copier</code> installation instructions. Then simply run</p> <pre><code>copier copy https://github.com/mbercx/python-copier &lt;package_name&gt;\n</code></pre> <p>And answer the questions to generate a new Python package.</p>"},{"location":"#next-steps","title":"Next steps","text":"<p>After copying the template, you might still have to do some additional configuration.</p>"},{"location":"#deploy-documentation","title":"Deploy documentation","text":""},{"location":"#read-the-docs","title":"Read the Docs","text":"<ol> <li>Push your code to GitHub.</li> <li>Go to Read the Docs (RTD) and import your project.    The build will use the included <code>.readthedocs.yaml</code> automatically.</li> <li>Set the RTD settings to build from GitHub pull requests.</li> </ol>"},{"location":"design/","title":"Design","text":""},{"location":"design/#build-system","title":"Build system","text":"<p>This template uses Hatch as the build backend and project manager.</p> <pre><code>[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n</code></pre>"},{"location":"design/#why-choose-hatch","title":"\u2705 Why choose Hatch?","text":"<p>Hatch is a modern, PEP 517-compliant build backend. Main features:</p> <p>Tool consolidation</p> <p>Hatch can also manage virtual environments, test runners, and formatters (e.g. <code>hatch fmt</code>), reducing reliance on multiple tools.</p> <p>PEP 621 support</p> <p>Clean, declarative configuration in <code>pyproject.toml</code>. Keeping the number of configuration files minimal.</p> <p>Integrated versioning</p> <p>Instead of hardcoding the version number in <code>pyproject.toml</code>, we delegate it to a separate file (<code>__about__.py</code>) inside the source tree. This pattern has a few advantages:</p> <ul> <li>Single source of truth: The version lives inside your package, making it accessible at runtime via <code>import</code>.</li> <li>Tool-friendly: Hatch can automatically read and update this file using <code>[tool.hatch.version]</code>, supporting both static and dynamic versioning.</li> <li>Clean packaging: Keeps <code>pyproject.toml</code> minimal, and avoids cluttering the <code>__init__.py</code> with metadata.</li> </ul>"},{"location":"design/#documentation","title":"Documentation","text":"<p>The user can select which documentation engine they prefer. Some information on the two options is already provided below, this will be fleshed out more as both frameworks are tested more rigorously.</p>"},{"location":"design/#myst-markdown","title":"MyST Markdown","text":"<p>MyST Markdown is a Markdown-based documentation tool that avoids Sphinx' reStructuredText format while preserving most of its power. The main reason to use this over MkDocs to test the Jupyter notebook integration, especially the \"executable content\". MyST is also easy to integrate with Sphinx, which has a lot of powerful tools, especially for scientific software.</p>"},{"location":"design/#mkdocs","title":"MkDocs","text":"<p>MkDocs is another Markdown-based documentation tool that focusses even more on simplicity. Some features:</p> <ol> <li>Very simple to build and write, not too much faff.</li> <li>Builds/serves very fast (faster than MyST in my experience).</li> <li>Static pages, easy to host.</li> <li>Sleek look, using Material for MkDocs.</li> </ol>"},{"location":"design/#devops","title":"DevOps","text":"<p>This template includes development automation tools that ensure code quality, consistency, and developer efficiency.</p>"},{"location":"design/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run automated checks before each commit. The configuration is stored in <code>.pre-commit-config.yaml</code>, and only uses <code>hatch fmt</code> in two separate steps:</p> <ul> <li><code>hatch fmt -f</code></li> <li><code>hatch fmt -l</code></li> </ul> <p>The steps are separated in first formatting the code, then linting it to check for issues.</p>"},{"location":"dev-standards/","title":"Development standards","text":"<p>Good development standards make for better code.</p> <p>Versioning: We try to adhere to SemVer.</p> <p>Note</p> <p>The stipulations below are based on experience, but are still evolving. This text is mainly here to provide a starting point for discussion with collaborators. </p>"},{"location":"dev-standards/#commit-messages","title":"Commit messages","text":"<p>A well-cared for (commit) log is a beautiful and useful thing</p> <p>This quote comes from the following article, which should be considered a mandatory read for anyone maintaining a package:</p> <p>https://cbea.ms/git-commit/</p> <p>The summary, slightly adapted by personal preferences (indicated in boldface):</p> <ul> <li>Separate subject/title from body with a blank line.</li> <li>Limit the subject line to 50 characters if possible, 72 is a hard limit.</li> <li>Capitalize the subject line and do not end it with a period.</li> <li>Use the imperative mood in the subject line.</li> <li>Wrap the body at 88 characters.</li> <li>Use the body to explain what and why vs. how.</li> </ul> <p>In addition, try to make atomic commits when possible. We've also taken inspiration from the MyST parser contribution guide.<sup>1</sup> </p> <p>Here is an example of the desired format for a commit message:</p> <pre><code>&lt;TYPE-EMOJI&gt; &lt;SCOPE&gt;: Summarize changes in 72 characters or less\n\nMore detailed explanatory text, if necessary. Explain the problem that this\ncommit is solving. Focus on what you are changing, why you are making this\nchange and why you chose your approach, as opposed to how the change was made\n(the code and comments should explain that). Are there side effects or other\nunintuitive consequences of this change? Here's the place to explain the\ncontext of your commit to someone else reading your message in the future\n(most likely you).\n\nPS: There is no need to mention you also added unit tests when adding a new\n    feature. The code diff already makes this clear.\n</code></pre> <p>Besides being an invaluable resources for future maintainers, writing a commit message forces you to explain your change. It forces you to stop and think again. Is this really the best approach to solving the issue? If it's hard to explain the change, maybe it's a bad idea?</p>"},{"location":"dev-standards/#specifying-the-type-of-change","title":"Specifying the type of change","text":"<p>Specifying the type of change in a commit can be useful for several reasons:</p> <ul> <li>Understanding the changes of a commit.</li> <li>Where to (automatically) put the commit in the changelog, if at all.</li> <li>What to include in a support branch for a previous major release.</li> <li>Encouraging atomic commits.</li> <li>What the priority should be when reviewing open PRs. </li> </ul> <p>We use exactly one leading emoji per commit to indicate the type of change. Some advantages:</p> <ul> <li>Only a single character needed!   Save precious space in the subject line.</li> <li>A clear visual indicator of the type of change.</li> <li>Clearly separates type from scope/content.</li> <li>Language-agnostic.</li> <li>They look great. At least on macOS.</li> </ul> <p>Important</p> <p>Although we are in favor of using leading emojis to indicate the type, we do not allow emojis further down the subject line. This makes it easier to <code>grep</code> for commit types.</p> <p>The list in the table below is in order of priority, e.g. a backwards-incompatible change might improve an existing feature by breaking its API, but should not be typed as an improvement (\ud83d\udc4c). Similarly, if a dependency is changed, it's convenient to quickly spot this, e.g. when updating a conda feedstock.</p> Emoji Meaning Similar to Angular type In changelog summary? \ud83d\udca5 introduce a backward-incompatible (breaking) change / remove deprecated code <code>\\&lt;type&gt;!</code> (use <code>!</code> + <code>BREAKING CHANGE:</code>) Yes \ud83d\udce6 add, update or change a dependency <code>build</code> Yes \u2728 introduce new features <code>feat</code> Yes \ud83d\udc4c improve an existing code/feature (no breaking) <code>perf</code>/<code>feat</code> Yes \ud83d\udc1b fix a code bug <code>fix</code> Yes \u274c mark code as deprecated (note removal version/replacement) <code>refactor</code> Yes \ud83d\udcda add or adapt documentation <code>docs</code> No \ud83d\udd04 refactor existing code with no behavior change <code>refactor</code> No \ud83e\uddea add or adapt tests <code>test</code> No \ud83d\ude80 bump the package version for release <code>chore</code> No \ud83e\uddf9 clean up comments / small formatting <code>style</code> No \u23ea revert a previous commit <code>revert</code> No \ud83d\udd27 devops-related changes (pre-commit, CI/CD, etc.) <code>ci</code> No \ud83d\udc2d minor changes (typos etc.; exclude from changelog) <code>chore</code> No \u2753 anything not covered above (last resort) <code>chore</code> No <p>Note</p> <p>We are aware of other standards like GitMoji, but limit the number in order to avoid choice overload. Too many options make it difficult for contributors to know all of them, makes changelogs too fragmented and leads to decision paralysis. Moreover, we avoid emojis that typically have width issues in some terminals. </p> <p>Note</p> <p>Not everyone likes emojis. In the dropdown below you can find some common concerns.</p> Common concerns <p>Tooling can\u2019t parse emojis.</p> <p>We haven't needed to use much tooling so far, and built our own for e.g. the changelog.</p> <p>Search/<code>grep</code> is harder.</p> <p>You can <code>grep</code> for emojis too! In fact, it's easier to exclusively find the commits you are looking for:</p> <pre><code>git log --oneline | grep '[\ud83d\udca5\u2728\ud83d\udc4c\ud83d\udc1b\u274c\ud83d\udce6]'\n</code></pre> <p>Using e.g. <code>test</code> to <code>grep</code> for the type will likely also find commits of other types.</p> <p>Accessibility / screen readers read \u2018sparkles\u2019</p> <p>This is a fair point. In case we start working with collaborators that rely on such tools we will adapt.</p> <p>Rendering/width issues in some terminals.</p> <p>We selected emojis with default emoji presentation (no variation selector), which render correctly in modern terminals.</p> <p>Ambiguity / overchoice</p> <p>This just depends on conventions. You can have more ASCII keywords to choose from. If we keep a small, fixed set, like the one above, this is not an issue.</p> <p>Not serious/professional.</p> <p>The icon is metadata, not decoration. It improves triage and doesn\u2019t replace clear subjects/bodies.</p>"},{"location":"dev-standards/#collaboration-on-github","title":"Collaboration on GitHub","text":""},{"location":"dev-standards/#review-process","title":"Review process","text":"<ol> <li>Don't update the branch with merges, rebase instead.    This makes the branches easier to understand, avoids merge commits (evil!), and allows for squashing commits as desired.</li> <li>Keep commits clean and as desired for the final PR merge.    Adding commit after commit means the PR has to be reviewed in its entirety.    This is fine for smaller changes, but for more complicated PRs you should try to split up the relevant changes in atomic commits that deal with a single type/scope.    Keeping commits isolated and clean makes review easier, since each change can be reviewed in isolation, along with the explanation in the commit message.    Exceptions here are changes based on review, see the next point.</li> <li>Keep changes based on review in a single separate commit.    After you are done with processing a review, you ping the reviewer again to see if they are happy with your updates.    However, how will they know what you have changed?    If you simply integrate the changes in the final commits, as described above, they can't isolate what you have changed based on their review.    If you add 10 more commits, it still is difficult to see what you changed in one view.    By keeping all the changes made based on a review in a single commit, you make subsequent review easier and faster.</li> </ol> <ol> <li> <p>Shoutout to my boi Chris Sewell. The man, the legend. The quintessential British b***ard.\u00a0\u21a9</p> </li> </ol>"},{"location":"developer/","title":"Developer Guide","text":"<p>Info</p> <p>Just to clarify: this guide is for developers of the <code>copier</code> template, not Python package developers.</p> <p>This template package uses several Hatch environments to execute developer tasks or \"scripts\". To see the environments and their corresponding scripts, run:</p> <pre><code>hatch env show\n</code></pre> <p>You can also find the definition of all the environments and their script in the <code>pyproject.toml</code>.</p> <p>Info</p> <p>Hatch creates its own isolated Python environments behind the scenes to run the corresponding scripts. This means your current environment will not be affected.</p>"},{"location":"developer/#default-template-scripts","title":"Default - Template scripts","text":"<p>The default Hatch environment defines a set of scripts related to the template, for example:</p> <pre><code>hatch run copy &lt;target_directory&gt;\n</code></pre> <p>Will copy the fully rendered template as the <code>py-package</code> package in the <code>&lt;target_directory&gt;</code>. Other scripts for the default environment:</p> <ul> <li><code>check</code>: Copy/Update the template in the <code>.tmp</code> directory and check the rendered files by linting them with <code>hatch fmt -l</code>.</li> <li><code>clean</code>: Remove the <code>.tmp</code> directory and any Ruff caches.</li> <li><code>install</code>: Copy/Update the template in the <code>.tmp</code> directory and install it with <code>uv pip install</code>.</li> <li><code>test</code>: Copy/Update the template in the <code>.tmp</code> directory run the test suite with <code>pytest</code>.</li> </ul>"},{"location":"developer/#documentation","title":"Documentation","text":"<p>The <code>docs</code> Hatch environment can be used to <code>build</code>, <code>serve</code> and <code>deploy</code> the documentation of this template package (which you are reading right now). To run these scripts, you need to specify the <code>docs</code> environment in the <code>hatch run</code> command:</p> <pre><code>hatch run docs:serve\n</code></pre> <p>Warning</p> <p>The <code>docs:deploy</code> script will use <code>mkdocs gh-deploy</code> to deploy the documentation as a GitHub Pages website. This should rarely be done manually, since we have a GitHub Action set up to do this.</p>"},{"location":"developer/#release","title":"Release","text":"<p>To make a new release of the template package, simply tag the commit you want to release:</p> <pre><code>git tag -a v0.3.0 -m '\ud83d\ude80 Release `v0.3.0`'\n</code></pre> <p>And then push the tag to the remote, here named <code>origin</code>:</p> <pre><code>git push origin --tags\n</code></pre> <p>You can the go to the Github releases and make a new release based on the new tag.</p>"},{"location":"semantics/","title":"Semantics","text":"<p>You may be sure, my dear Cebes, that inaccurate language is not only itself a mistake; it implants evil in men's souls. - Socrates</p> <ul> <li>Localized code: Keep meaning and effects close to where they\u2019re used. Prefer small, single-purpose functions, tight scopes, and minimal globals so behavior is easy to reason about and change safely.</li> </ul>"},{"location":"semantics/#acronyms","title":"Acronyms","text":"<ul> <li>EAFP: Easier to ask forgiveness than permission - write the straightforward operation and handle the specific failure (<code>try</code>/<code>except</code>) instead of pre-checking.</li> </ul>"}]}